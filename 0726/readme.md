# 🚩시간복잡도 & 빅오 표기법

### 1. 알고리즘의 시간 복잡도

> ##### 사용하는 함수,메소드를 활용만 하는 것이 아닌 시간복잡도를 생각하며 좋은 알고리즘을 만들자!!

- 좋은 알고리즘이란?

  - 입력(input)을 넣은 후 출력(output)이 나오는 시간이 짧은 알고리즘

- 알고리즘의 소요 시간 측정하기

  - 객관적이 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 살펴본다.

  - 기본연산의 총 횟수 == 알고리즘의 소요 시간

    기본연산(단위 시간 1이 소요되는 연산)

  - 성능을 측정할 때는 입력을 통일하며, 입력값은 최악의 경우로

    

### 2. 빅오(Big-O) 표기법

> ##### 같은 output의 알고리즘이라도 시간복잡도에 따라 성능이 달라질 수 있고 문제의 정답 여부를 가른다.

- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하데 표시하는것

  최고차항만 남기고 계수와 상수 제거 

- 내장 함수, 메서드의 시간 복잡도도 확인 할 필요가 있다



> ##### 반복문을 1번만 사용하더라도 반목문 안의 내장함수가 시간복잡도가 높다면 이중 반복문과 같아짐!!!

---

# 🚩 리스트

### 1. 배열 vs 연결리스트

- 배열 : 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
  - 인덱스를 통해 데이터를 빠르게 접근
  - 베열의 길이는 변경 불가능 -> 길이 변경하고 싶다면 새로 생성

- 연결 리스트 : 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조
  - 맨 처음 노드부터 순차적으로 탐색
  - 연결리스트의 길이 자유롭게 변경 가능 -> 삽입, 삭제가 편리

> 파이썬의 리스트는 두 가지를 모두 가지고 있다

### 2. 파이썬의 리스트

- 메소드

  1. append(원소)
     - 리스트 맨 끝에 새로운 원소 삽입
  2. pop(인덱스)
     - 특정 인덱스에 있는 원소를 삭제 및 반환

  3. count(원소)
     - 리스트에서 해당 원소의 개수 반환

  4. index(원소)
     - 리스트에서 처음으로 원소가 등장하는 인덱스 반환
  5. sort()
     - 리스트를 오름차순으로 정렬

  6. reverse()
     - 리스트의 원소들의 순서를 거꾸로 뒤집기